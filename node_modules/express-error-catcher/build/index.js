"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Error: () => errorHandler_default,
  Response: () => responseHandler_default,
  asyncErrorHandler: () => asyncErrorHandler_default,
  error: () => error_default
});
module.exports = __toCommonJS(src_exports);

// src/responseHandler.ts
var Response = class {
  message;
  data;
  statusCode;
  constructor(message, data, statusCode) {
    this.message = message;
    this.data = data;
    this.statusCode = statusCode;
  }
};
var responseHandler_default = Response;

// src/asyncErrorHandler.ts
var import_http_status_codes = require("http-status-codes");

// src/helper/index.ts
function isNull(field) {
  return field === null || field === void 0 || field === "" || field === "undefined";
}

// src/asyncErrorHandler.ts
var tryCatch = (errFunction) => async (req, res, next) => {
  try {
    const result = await errFunction(req, res, next);
    if (result instanceof responseHandler_default) {
      ResponseHandler(res, result);
    }
    return;
  } catch (error) {
    return next(error);
  }
};
var ResponseHandler = (res, result) => {
  let response = {
    code: result.statusCode,
    success: true,
    status: (0, import_http_status_codes.getReasonPhrase)(result.statusCode)
  };
  if (!isNull(result.message)) {
    response.message = result.message;
  }
  if (!isNull(result.data)) {
    response = { ...response, ...result.data };
  }
  res.status(result.statusCode).json(response);
};
var asyncErrorHandler_default = tryCatch;

// src/error.ts
var import_http_status_codes2 = require("http-status-codes");
var ErrorHandler = class extends Error {
  statusCode;
  data;
  constructor(message, statusCode, data) {
    super(message);
    this.statusCode = statusCode;
    this.data = data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var logFormatter = (...prop) => {
  console.log("<------------------------------->");
  for (const i of prop) {
    console.log(i);
  }
  console.log("<------------------------------->");
};
var createErrorHandler = (options) => {
  const middleware = (err, req, res, next) => {
    err.statusCode = err.statusCode || options?.defaultStatusCode || 500;
    err.message = err.message || options?.defaultErrorMessage || "Internal Server Error";
    if (options?.log) {
      const logErrorLocation = (stack) => {
        if (stack) {
          const stackLines = stack.split("\n");
          if (stackLines.length > 1) {
            const errorLocation = stackLines[1].trim();
            if (options.log === "dev") {
              logFormatter(`ERROR => ${err.message}`, `FILE => ${errorLocation.replace("at ", "")}`);
            } else if (options.log === "pretty") {
              console.table([{ Message: err.message, File: errorLocation.replace("at ", "") }]);
            } else if (options.log === "production") {
              logFormatter(`ERROR => ${err.message}`);
            }
          }
        }
      };
      logErrorLocation(err.stack);
    }
    if (err.name === "CastError") {
      const message = `Resource Not Found. Invalid: ${err.path}`;
      err = new ErrorHandler(message, 400);
    }
    if (err.code === 11e3) {
      const message = `Duplicate ${Object.keys(err.keyValue)} entered`;
      err = new ErrorHandler(message, 400);
    }
    if (err.name === "JsonWebTokenError") {
      const message = "JWT Error";
      err = new ErrorHandler(message, 400);
    }
    if (err.name === "TokenExpiredError") {
      const message = "JWT is Expired";
      err = new ErrorHandler(message, 400);
    }
    const response = {
      success: false,
      code: err.statusCode,
      status: (0, import_http_status_codes2.getReasonPhrase)(err.statusCode),
      message: err.message
    };
    if (err.data) {
      response.data = err.data;
    }
    res.status(err.statusCode).json(response);
  };
  return middleware;
};
var errorHandler = (optionsOrErr, req, res, next) => {
  let err = optionsOrErr instanceof Error;
  if (err) {
    const err2 = optionsOrErr;
    const middleware = createErrorHandler();
    return middleware(err2, req, res, next);
  } else {
    return createErrorHandler(optionsOrErr);
  }
};
var error_default = errorHandler;

// src/errorHandler.ts
var ErrorHandler2 = class extends Error {
  statusCode;
  data;
  constructor(message, statusCode, data) {
    super(message);
    this.statusCode = statusCode;
    this.data = data;
    Error.captureStackTrace(this, this.constructor);
  }
};
var errorHandler_default = ErrorHandler2;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Error,
  Response,
  asyncErrorHandler,
  error
});
