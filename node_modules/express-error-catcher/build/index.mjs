// src/responseHandler.ts
var Response = class {
  message;
  data;
  statusCode;
  constructor(message, data, statusCode) {
    this.message = message;
    this.data = data;
    this.statusCode = statusCode;
  }
};
var responseHandler_default = Response;

// src/asyncErrorHandler.ts
import { getReasonPhrase } from "http-status-codes";

// src/helper/index.ts
function isNull(field) {
  return field === null || field === void 0 || field === "" || field === "undefined";
}

// src/asyncErrorHandler.ts
var tryCatch = (errFunction) => async (req, res, next) => {
  try {
    const result = await errFunction(req, res, next);
    if (result instanceof responseHandler_default) {
      ResponseHandler(res, result);
    }
    return;
  } catch (error) {
    return next(error);
  }
};
var ResponseHandler = (res, result) => {
  let response = {
    code: result.statusCode,
    success: true,
    status: getReasonPhrase(result.statusCode)
  };
  if (!isNull(result.message)) {
    response.message = result.message;
  }
  if (!isNull(result.data)) {
    response = { ...response, ...result.data };
  }
  res.status(result.statusCode).json(response);
};
var asyncErrorHandler_default = tryCatch;

// src/error.ts
import { getReasonPhrase as getReasonPhrase2 } from "http-status-codes";
var ErrorHandler = class extends Error {
  statusCode;
  data;
  constructor(message, statusCode, data) {
    super(message);
    this.statusCode = statusCode;
    this.data = data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var logFormatter = (...prop) => {
  console.log("<------------------------------->");
  for (const i of prop) {
    console.log(i);
  }
  console.log("<------------------------------->");
};
var createErrorHandler = (options) => {
  const middleware = (err, req, res, next) => {
    err.statusCode = err.statusCode || options?.defaultStatusCode || 500;
    err.message = err.message || options?.defaultErrorMessage || "Internal Server Error";
    if (options?.log) {
      const logErrorLocation = (stack) => {
        if (stack) {
          const stackLines = stack.split("\n");
          if (stackLines.length > 1) {
            const errorLocation = stackLines[1].trim();
            if (options.log === "dev") {
              logFormatter(`ERROR => ${err.message}`, `FILE => ${errorLocation.replace("at ", "")}`);
            } else if (options.log === "pretty") {
              console.table([{ Message: err.message, File: errorLocation.replace("at ", "") }]);
            } else if (options.log === "production") {
              logFormatter(`ERROR => ${err.message}`);
            }
          }
        }
      };
      logErrorLocation(err.stack);
    }
    if (err.name === "CastError") {
      const message = `Resource Not Found. Invalid: ${err.path}`;
      err = new ErrorHandler(message, 400);
    }
    if (err.code === 11e3) {
      const message = `Duplicate ${Object.keys(err.keyValue)} entered`;
      err = new ErrorHandler(message, 400);
    }
    if (err.name === "JsonWebTokenError") {
      const message = "JWT Error";
      err = new ErrorHandler(message, 400);
    }
    if (err.name === "TokenExpiredError") {
      const message = "JWT is Expired";
      err = new ErrorHandler(message, 400);
    }
    const response = {
      success: false,
      code: err.statusCode,
      status: getReasonPhrase2(err.statusCode),
      message: err.message
    };
    if (err.data) {
      response.data = err.data;
    }
    res.status(err.statusCode).json(response);
  };
  return middleware;
};
var errorHandler = (optionsOrErr, req, res, next) => {
  let err = optionsOrErr instanceof Error;
  if (err) {
    const err2 = optionsOrErr;
    const middleware = createErrorHandler();
    return middleware(err2, req, res, next);
  } else {
    return createErrorHandler(optionsOrErr);
  }
};
var error_default = errorHandler;

// src/errorHandler.ts
var ErrorHandler2 = class extends Error {
  statusCode;
  data;
  constructor(message, statusCode, data) {
    super(message);
    this.statusCode = statusCode;
    this.data = data;
    Error.captureStackTrace(this, this.constructor);
  }
};
var errorHandler_default = ErrorHandler2;
export {
  errorHandler_default as Error,
  responseHandler_default as Response,
  asyncErrorHandler_default as asyncErrorHandler,
  error_default as error
};
